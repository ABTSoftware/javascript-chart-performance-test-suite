// @ts-check
import { test, expect } from '@playwright/test';
import fs from 'fs';
import path from 'path';

// Read test URLs from the file generated by global setup
const testDataPath = path.join(process.cwd(), 'tests', 'test-urls.json');
/** @type {{ hrefs: string[] }} */
let testData = { hrefs: [] };

try {
    const fileContent = fs.readFileSync(testDataPath, 'utf-8');
    testData = JSON.parse(fileContent);
} catch (error) {
    console.error('Failed to read test URLs from global setup:', error);
}

/** @type {string[]} */
const hrefs = testData.hrefs;

// Shared context and page for all tests to maintain IndexedDB state
/** @type {import('@playwright/test').BrowserContext} */
let context;

// Path to store the browser state (including IndexedDB)
const storageStatePath = path.join(process.cwd(), 'tests', 'storage-state.json');

// Configure tests to run serially and share browser context for IndexedDB persistence
test.describe.configure({ mode: 'serial' });

test.describe('Test each chart library', () => {
    test.beforeAll(async ({ browser }) => {
        console.warn('beforeAll');
        // Create a persistent context that will be shared across all tests
        if (!context) {
            console.warn('get new context');

            // Load existing storage state if it exists
            /** @type {import('@playwright/test').BrowserContextOptions} */
            const contextOptions = {};
            if (fs.existsSync(storageStatePath)) {
                console.log('Loading existing storage state from:', storageStatePath);
                contextOptions.storageState = storageStatePath;
            }

            context = await browser.newContext(contextOptions);
        }
    });

    test.afterAll(async () => {
        // Save storage state (including IndexedDB) for future test runs
        if (context) {
            console.log('Saving storage state to:', storageStatePath);
            await context.storageState({ path: storageStatePath, indexedDB: true });
            await context.close();
        }
    });

    for (const href of hrefs) {
        // Generate test name from URL - trim first segment
        const urlParts = href.split('/').filter((part) => part.length > 0);
        const testName = urlParts.slice(1).join('/') || href;

        test(testName, async () => {
            test.setTimeout(300000);

            console.log(`Test: ${testName} - ${href}`);
            const page = await context.newPage();

            await page.goto(`http://localhost:5173/${href}`);
            await page.waitForSelector('.results-table-ready', { timeout: 300000 });

            // Generate PDF filename from URL - sanitize the href for filename
            const pdfFilename = href.replace(/[^a-zA-Z0-9]/g, '-') + '.pdf';
            await page.pdf({ path: pdfFilename, format: 'A4' });
        });
    }

    test('Results Summary', async () => {
        console.log('refresh summary');
        const page = await context.newPage();
        await page.goto('http://localhost:5173/');
        await page.waitForSelector('.results-ready');

        // Save the initial page as PDF
        await page.pdf({ path: 'results-summary-page.pdf', format: 'A4' });
    });
});
